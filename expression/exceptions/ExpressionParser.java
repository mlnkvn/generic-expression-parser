package expression.exceptions;import expression.*;import expression.parser.BaseParser;import expression.parser.StringSource;import java.util.*;public class ExpressionParser implements TripleParser {    @Override    public All parse(String source) {        return new ExParser(source).parseExpression();    }    private static class ExParser extends BaseParser {        public ExParser(String source) {            super(new StringSource(source));        }        public All parseExpression() {            final All result = parseElement(false, false);            if (eof()) {                return result;            }            throw error("End of Expression expected");        }        private All parseElement(boolean isInBrackets, boolean isInUnary) {            skipAllWhitespace();            ArrayList<String> operations = new ArrayList<>();            ArrayList<Integer> priorities = new ArrayList<>();            ArrayList<All> elements = new ArrayList<>();            while (!eof()) {                skipAllWhitespace();                if (operations.size() == elements.size()) {                    if (test('-') || test('l') || test('t')) {                        String operation = getUnary();                        skipAllWhitespace();                        if (eof()) {                            throw new ArgumentNumberException("No matching argument for unary operation");                        }                        if (take('(')) {                            elements.add(defineUnary(operation, parseElement(true, false), true));                        } else if (test('-') || test('l') || test('t')) {                            elements.add(defineUnary(operation, parseElement(isInBrackets, true), false));                        } else if (isDigit()) {                            if (operation.equals("-")) {                                elements.add(parseVariableOrConst(true));                            } else {                                elements.add(defineUnary(operation, parseVariableOrConst(false), false));                            }                        } else if (isVariable()) {                            elements.add(defineUnary(operation, parseVariableOrConst(false), false));                        } else {                            throw new ArgumentNumberException("No matching argument for unary operation");                        }                        if (isInUnary) {                            return toExpression(elements, operations, priorities);                        }                    } else if (take('(')) {                        elements.add(parseElement(true, false));                    } else if (isDigit() || isVariable()) {                        elements.add(parseVariableOrConst(false));                    } else {                        throw new ArgumentNumberException("Missing argument in binary operation");                    }                } else if (take(')')) {                    if (!isInBrackets) {                        throw new BracketNumberException("No matching opening parenthesis");                    }                    return toExpression(elements, operations, priorities);                } else if (take('(')) {                    throw new OperationNumberException("Missing operation");                } else if (test('*') || test('/')) {                    operations.add(String.valueOf(take()));                    priorities.add(0);                } else if (test('+') || test('-')) {                    operations.add(String.valueOf(take()));                    priorities.add(1);                } else if (test('m')) {                    operations.add(minOrMax());                    priorities.add(2);                } else if (isVariable() || isDigit()) {                    throw new OperationNumberException("Missing operation");                } else {                    throw new IllegalArgumentException("Unexpected symbol");                }            }            if (isInBrackets) {                throw new BracketNumberException("Closing parenthesis expected");            }            if (eof()) {                return toExpression(elements, operations, priorities);            }            throw error("End of Expression expected");        }        private String getUnary() {            StringBuilder operation = new StringBuilder();            operation.append(take());            while (!eof() && !isDigit() && !isVariable() && !isWhitespace() && !test('-') && !test('(')) {                operation.append(take());            }            if (operation.toString().equals("l") || operation.toString().equals("t")) {                while (!eof() && !isWhitespace() && !test('-') && !test('(')) {                    operation.append(take());                }            }            skipAllWhitespace();            if (operation.toString().equals("-") || operation.toString().equals("l0") || operation.toString().equals("t0")) {                return operation.toString();            }            throw new IllegalOperationException("Unsupported operation type: " + operation);        }        private All defineUnary(String operation, All expression, boolean hasBrackets) {            if (operation.equals("l0")) {                return new CheckedL0(expression, hasBrackets);            } else if (operation.equals("t0")) {                return new CheckedT0(expression, hasBrackets);            } else {                return new CheckedNegate(expression, hasBrackets);            }        }        private String minOrMax() {            StringBuilder operation = new StringBuilder("");            while (!eof() && !isDigit() && !isWhitespace() && !test('-') && !test('(')) {                operation.append(take());            }            skipAllWhitespace();            if (operation.toString().equals("min")) {                return "min";            } else if (operation.toString().equals("max")) {                return "max";            }            throw new IllegalOperationException("Unsupported operation type: " + operation);        }        private All toExpression(ArrayList<All> elements, ArrayList<String> operations, ArrayList<Integer> priorities) {            if (elements.size() != operations.size() + 1) {                throw new ArgumentNumberException("Missing argument in binary operation");            }            if (elements.size() == 1) {                return elements.get(0);            }            int res = 0;            int prev = findNext(-1, elements);            int next = findNext(prev, elements);            int cnt = 0;            for (int i = 0; i < operations.size() && next < elements.size(); i++) {                if (priorities.get(i) == 0) {                    elements.set(next, getOperation(elements.get(prev), elements.get(next), operations.get(i)));                    elements.set(prev, null);                    res = next;                    prev = next;                    cnt++;                    next = findNext(next, elements);                } else {                    prev = next;                    next = findNext(next, elements);                }            }            prev = findNext(-1, elements);            next = findNext(prev, elements);            if (cnt == operations.size()) {                return elements.get(res);            }            for (int i = 0; i < operations.size() && next < elements.size(); i++) {                if (priorities.get(i) == 1) {                    elements.set(next, getOperation(elements.get(prev), elements.get(next), operations.get(i)));                    elements.set(prev, null);                    cnt++;                    res = next;                    prev = next;                    next = findNext(next, elements);                } else if (cnt != operations.size() - 1 && priorities.get(i) == 2) {                    prev = next;                    next = findNext(next, elements);                }            }            if (cnt == operations.size()) {                return elements.get(res);            }            prev = findNext(-1, elements);            next = findNext(prev, elements);            for (int i = 0; i < operations.size() && next < elements.size(); i++) {                if (priorities.get(i) == 2) {                    elements.set(next, getOperation(elements.get(prev), elements.get(next), operations.get(i)));                    elements.set(prev, null);                    res = next;                    cnt++;                    prev = next;                    next = findNext(next, elements);                }            }            return elements.get(res);        }        private int findNext(int next, ArrayList<All> elements) {            int i = next + 1;            while (i < elements.size() && elements.get(i) == null) {                i++;            }            return i;        }        private All getOperation(All first, All second, String operand) {            switch (operand) {                case "+":                    return new CheckedAdd(first, second);                case "-":                    return new CheckedSubtract(first, second);                case "*":                    return new CheckedMultiply(first, second);                case "/":                    return new CheckedDivide(first, second);                case "min":                    return new Min(first, second);                case "max":                    return new Max(first, second);                default:                    return new Const(0);            }        }        private All parseVariableOrConst(boolean isNegative) {            skipAllWhitespace();            final StringBuilder part = new StringBuilder();            if (isNegative) {                part.append("-");            }            boolean reached = false;            skipAllWhitespace();            while (isDigit()) {                part.append(take());                reached = true;            }            if (reached) {                if (isAlphabetic()) {                    throw new IllegalOperationException("Unsupported operation");                }                return new Const(Integer.parseInt(part.toString()));            }            while (isVariable()) {                part.append(take());            }            return new Variable(part.toString());        }    }}