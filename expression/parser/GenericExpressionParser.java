package expression.parser;import expression.exceptions.*;import expression.generic.*;import java.util.*;public class GenericExpressionParser<T> {    protected NumberMode<T> calculator;    public GenericExpressionParser(NumberMode<T> calculator) {        this.calculator = calculator;    }    public GenericGeneralExpression<T> parse(String source) {        return new ExParser<T>(source, calculator).parseExpression();    }    private static class ExParser<T> extends BaseParser {        protected NumberMode<T> calculator;        public ExParser(String source, NumberMode<T> calculator) {            super(new StringSource(source));            this.calculator = calculator;        }        public GenericGeneralExpression<T> parseExpression() {            final GenericGeneralExpression<T> result = parseElement(false);            if (eof()) {                return result;            }            throw error("End of Expression expected");        }        private GenericGeneralExpression<T> parseElement(boolean isInUnary) {            skipAllWhitespace();            ArrayList<String> operations = new ArrayList<>();            ArrayList<Integer> priorities = new ArrayList<>();            ArrayList<GenericGeneralExpression<T>> elements = new ArrayList<>();            while (!eof()) {                skipAllWhitespace();                if (operations.size() == elements.size()) {                    skipWhitespace();                    if (test('-') || test('c')) {                        String operation = getUnary();                        skipAllWhitespace();                        if (eof()) {                            throw new ArgumentNumberException("No matching argument for unary operation");                        }                        if (take('(')) {                            elements.add(defineUnary(operation, parseElement(false), true));                        } else if (test('-') || test('c')) {                            elements.add(defineUnary(operation, parseElement(true), false));                        } else if (isDigit()) {                            if (operation.equals("-")) {                                elements.add(parseVariableOrConst(true));                            } else {                                elements.add(defineUnary(operation, parseVariableOrConst(false), false));                            }                        } else if (isVariable()) {                            elements.add(defineUnary(operation, parseVariableOrConst(false), false));                        } else {                            throw new ArgumentNumberException("No matching argument for unary operation");                        }                        if (isInUnary) {                            return toExpression(elements, operations, priorities);                        }                    } else if (take('(')) {                        elements.add(parseElement(false));                    } else if (isDigit() || isVariable()) {                        elements.add(parseVariableOrConst(false));                    }                } else if (take(')')) {                    return toExpression(elements, operations, priorities);                } else if (test('*') || test('/')) {                    skipAllWhitespace();                    operations.add(String.valueOf(take()));                    priorities.add(0);                } else if (test('+') || test('-')) {                    skipAllWhitespace();                    operations.add(String.valueOf(take()));                    priorities.add(1);                } else if (test('m')) {                    operations.add(minOrMax());                    priorities.add(2);                }                skipAllWhitespace();            }            if (eof()) {                return toExpression(elements, operations, priorities);            }            throw error("End of Expression expected");        }        private String getUnary() {            StringBuilder operation = new StringBuilder();            operation.append(take());            while (!eof() && !isDigit() && !isVariable() && !isWhitespace() && !test('-') && !test('(')) {                operation.append(take());            }            if (operation.toString().equals("c")) {                while (!eof() && !isWhitespace() && !test('-') && !test('(')) {                    operation.append(take());                }            }            skipAllWhitespace();            if (operation.toString().equals("-") || operation.toString().equals("count")) {                return operation.toString();            }            throw new IllegalOperationException("Unsupported operation type: " + operation);        }        private GenericGeneralExpression<T> defineUnary(String operation, GenericGeneralExpression<T> expression, boolean hasBrackets) {            if (operation.equals("count")) {                return new Count<>(expression, hasBrackets, calculator);            } else {                return new GenericUnaryMinus<>(expression, hasBrackets, calculator);            }        }        private String minOrMax() {            StringBuilder operation = new StringBuilder();            skipAllWhitespace();            while (!isDigit() && !isWhitespace() && !test('-') && !test('(')) {                operation.append(take());            }            skipAllWhitespace();            if (operation.toString().equals("min")) {                return "min";            } else if (operation.toString().equals("max")) {                return "max";            }            throw new IllegalArgumentException("Unsupported operation type: " + operation);        }        private GenericGeneralExpression<T> toExpression(ArrayList<GenericGeneralExpression<T>> elements, ArrayList<String> operations, ArrayList<Integer> priorities) {            if (elements.size() == 1) {                return elements.get(0);            }            int res = 0;            int prev = findNext(-1, elements);            int next = findNext(prev, elements);            int cnt = 0;            for (int i = 0; i < operations.size() && next < elements.size(); i++) {                if (priorities.get(i) == 0) {                    elements.set(next, getOperation(elements.get(prev), elements.get(next), operations.get(i)));                    elements.set(prev, null);                    res = next;                    cnt++;                }                prev = next;                next = findNext(next, elements);            }            prev = findNext(-1, elements);            next = findNext(prev, elements);            if (cnt == operations.size()) {                return elements.get(res);            }            for (int i = 0; i < operations.size() && next < elements.size(); i++) {                if (priorities.get(i) == 1) {                    elements.set(next, getOperation(elements.get(prev), elements.get(next), operations.get(i)));                    elements.set(prev, null);                    cnt++;                    res = next;                    prev = next;                    next = findNext(next, elements);                } else if (cnt != operations.size() - 1 && priorities.get(i) == 2) {                    prev = next;                    next = findNext(next, elements);                }            }            if (cnt == operations.size()) {                return elements.get(res);            }            prev = findNext(-1, elements);            next = findNext(prev, elements);            for (int i = 0; i < operations.size() && next < elements.size(); i++) {                if (priorities.get(i) == 2) {                    elements.set(next, getOperation(elements.get(prev), elements.get(next), operations.get(i)));                    elements.set(prev, null);                    res = next;                    cnt++;                    prev = next;                    next = findNext(next, elements);                }            }            return elements.get(res);        }        private int findNext(int next, ArrayList<GenericGeneralExpression<T>> elements) {            int i = next + 1;            while (i < elements.size() && elements.get(i) == null) {                i++;            }            return i;        }        private GenericOperation<T> getOperation(GenericGeneralExpression<T> first, GenericGeneralExpression<T> second, String operand) {            switch (operand) {                case "+":                    return new GenericAdd<>(first, second, calculator);                case "-":                    return new GenericSubtract<>(first, second, calculator);                case "*":                    return new GenericMultiply<>(first, second, calculator);                case "/":                    return new GenericDivide<>(first, second, calculator);                case "min":                    return new GenericMin<>(first, second, calculator);                case "max":                    return new GenericMax<>(first, second, calculator);                default:                    return null;            }        }        private GenericGeneralExpression<T> parseVariableOrConst(boolean isNegative) {            skipWhitespace();            final StringBuilder part = new StringBuilder();            boolean reached = false;            if (isNegative) {                part.append("-");            }            skipWhitespace();            while (isDigit() || test('.')) {                part.append(take());                reached = true;            }            if (reached) {                return new GenericConst<>(calculator.parse(part.toString()), calculator);            }            while (isVariable()) {                part.append(take());            }            return new GenericVariable<>(part.toString());        }        private void skipWhitespace() {            skipAllWhitespace();        }    }}